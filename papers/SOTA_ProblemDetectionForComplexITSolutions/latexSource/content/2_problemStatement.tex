Self healing software frameworks which are described in \cite{khan2011self} and \cite{garlan2002model} benefit, in general, from the fact, that a program has just s limited number of states it can be in. So you can identify these error states, develop a heuristic to classify them and code instruction how to deal with it. This process requires really good knowledge of the program, but it is also involve in the development time of the program and it is maintained by its developers. The problematic part starts when you are running multiple program which interacts with each other, then you cannot deal only with a single states of single program, you have to analyze product states\footnote{We can see a product state as a set where each element is a state of each set of sates per used program. Total number of such product states is $\prod_{i=0}^{n} s_i$, where $n$ is number of used programs and $s_i$ count of different states of program $i$.} of all possible states of each used program. This become true especial for cluster solutions.

It is obvious that number of product states grows really fast, but it is still a limited set. The problem is that even the set of used programs can differ quit significantly and there is no group of developers who could implement any self healing approach for all combinations of used programs. At the first they would have to fully understand all existing solutions and as the second, it would not be profitable. In the end, it is necessary to dig in configurations and log files to specify conditions under which an error occurred and then try to solve it on your own or using help of others.

You can definitely argue, that such databases of possible error states with solutions exist. There are public services as StackOverFlow.com, BigResource.com and most of programs has its own error tracking system, which may contain useful information, but all problems tracked by these systems are created by humans. This can easy cause that some important setting my be missed and not mentioned which can result into even bigger confusion. The best solution would be to have a description created by and algorithm which would contain all setting information, this could be easily matched on your system setting and configuration. But then there is a problem, that people can be that such algorithm can also scan their sensitive data.

Another challenge related to log mining which is frequently discussed and which we are going to mention is how understandable are log messages them-self. To understand this problematic, let us highlight, that every log message about a software event which is written to a log file is an expression of a developer about what the event/error/exception means. And since everybody has different expressive and understanding skills, the message may not sufficient and format can differ quite a lot. This is also related to the fact, that developers are pushed to release code as soon as possible and it often happens to the detriment of technical documentations.